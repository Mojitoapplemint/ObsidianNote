# Paradigm
1. **Divide** the input into smaller subproblems
2. **Conquer** the subproblem *recusively*
3. **Combine** the solutions for the subproblems into a solution for the original probelm

# Counting Inversion
Assume that you are asked to count the number of inversions in an array
- Inversion of an array is a pair of elements that are **out of order**

$$[1,3,5,2,4,6]$$
 $\to$ $(3,2)$, $(5,2)$, $(5,4)$

```
Input: An array A of distinct Integers

Output: The number of inversions of A -the number of pairs(i,j) of array indices with i<j and A[i]>A[j] 
```

$\to$ Write down the array in order and in the given order. Connect those two one by one. Count the number of crossing pairs

![[Pasted image 20240920104853.png|300]]
 $\implies$ 3 crosses

## Worst-Case Scenario
![[Pasted image 20240920105635.png|300]]
 $\implies$ 15 crosses

If the array is in backward order, then it gives the largest number of pairs

For input size $n$
 $=\frac{n(n-1)}{2}$

``` python
#Input: Array A of n distinct integers
#Output: The number of inversions of A

numInv := 0
for i:=1 to n-1 do
	for j:=i+1 to n do
		if A[i]>A[j] then
			numInv++
return numInv
```

## Divide and Conquer Approach
Divide the array with one recursive call for the left hald of the array and one for the right half of the array

Classify the inversions $(i,j)$ as follows
- Left Inversion
	- Both $i,j$ are in the first half
	- $i,j\leq\frac{n}{2}$
- Right Inversion
	- Both $i,j$ are in the second half
	- $i,j>\frac{n}{2}$
- Split Inversion
	- $i\leq\frac{n}{2}< j$

Let's utilize the MergeSort that we've learned

```python
# Sort-and-CountInv

# input: Array A of n distinct integers
# output: Sorted array B with the same integer, and the number of inversions of A

if n=0 or n=1 then          # Base Case
	return (A,0)


```

# Matrix Multiplication

