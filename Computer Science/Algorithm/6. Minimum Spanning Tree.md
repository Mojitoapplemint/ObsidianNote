# Spanning Tree Problem
Minimum spanning tree problem is about connecting a bunch of objects as cheaply as possible
- Modeled with Graphs
	- $G(V,E)$ has two ingredients: vertices and edges
	- For this problem, we will consider only undirected graph

**Input:** Undirected graph $G(V,E)$ in which each edge $e$ has a rea;-valued cost $c_{e}$

**Output:** Compute a spanning tree of the graph with the minimum possible fum of edge costs

**Properties of Spanning Tree**
1) It should not contain a cycle
2) Should include a path between every pait of vertices

# Prim's Algorithm
1. Choose an arbitrary vertex. 
2. Observe all possible edges from the vertex in the current spanning tree
3. Choose the cheapest edge if it doesn't cause a cycle
4. Repeat this until all vertex are included

---
## Pseudocode
$X:=\{s\}$       **//** $s$ is an arbitrarily chosen vertex
$T:=\emptyset$           **//** Invariant: the edges in $T$ span $X$

**//** Main Loop
**while** there is an edge $(v,w)$ with $v\in X$, $w\not\in X$ **do**
	$(v^{*}, w^{*}) :=$ a Minimum-cost such edge
	add vertex $w^{*}$ to $X$
	add edge $(v^{*}, w^{*})$ to $T$
**return** $T$

- $T$ keeps track of the edges chosen
- $X$ keeps track the vertices spanned
- Each iteration is responsible for adding one new edge to $T$
- After $n-1$ iterations, $X$ contains all vertices
---
## Running Time: $\mathcal{O}(mn)$
Assume there are $n$ vertices and $m$ edges

Consider 
$$\text{(Total Running Time)}=\text{(\# Iteration)}\times \text{(\# Operations per Iteration)}$$

1. $\text{\# Iteration}$
- While loop iterates until it contains all vertices in the graph
	- Thus it iterates $n-1$ times
	- $\mathcal{O}(n)$

2. $\text{\# Operations per Iteration }$
- In each iteration, it searches all possible edges for the cheapest one
	- There are total $m$ edges
	- $\mathcal{O}(m)$

3. $\text{Total Running Time}$
- $\mathcal{O}(mn)$

# Kruskal's Algorithm
Unlike Prim's, rather than growing a single tree from a starting vertex, it can grow multiple trees in parallel
- It will create a single tree at the end
- Can choose the cheapest edge that is not connected to the starting vertex

1. Sort the list of edges in increasing order
2. From the beginning of the list (the cheapest edge), observe an edge
3. If that does not cause cycle, then add them in the current spanning tree
4. Repeat this until all vertex are included

---
## Pseudocode
**//** Preprocessing
$T:=\emptyset$
$\text{sort edges of E by cost}$   **//** e.g. using MergeSort
**//** Main Loop
**for** each $e\in E$, in nondecreasing order of cost **do**
	**if** $T\cup \{ e \}$ is acyclic **then**
		$T:=T\cup \{ e \}$
**return** $T$

---

## Running Time of Preprocessing: $\mathcal{O}(m\log (n))$
Assume that there are $n$ vertices and $m$ edges. 
- Sorting $m$ edges by its costs
	- Assume that we use MergeSort
	- Then, it would be $m\log(m)$
	- However, we can express this in different way
- The minimum number of edges required to create the spanning tree is $n-1$
- And the maximum number of edges required is $_{n}C_{2}=\frac{n(n-1)}{2}$
- Then,
$$n-1\leq m \leq\frac{n(n-1)}{2}$$
$$\implies \log(n)\leq \log(m) \leq 2\log(n)$$
- Thus $\log(m)$ and $\log(n)$ are interchangeable
- $\therefore \mathcal{O}(m\log(n))$

## Running Time for Main Loop: $\mathcal{O}(mn)$
1. for loop is iterating for all edges, thus there are $m$ iterations
2. In each iteration, it checks whether termination vertex is included in $T$ or not, thus linear search
	- Therefore, $\mathcal{O}(n)$
3. Total Running Time for Main Loop is $\mathcal{O}(mn)$

## Total Running Time: $\mathcal{O}(mn)$
It would be 
$$\mathcal{O}(m\log(n))+\mathcal{O}(mn)\approx \mathcal{O}(mn)$$


# Union-Find Based Kruskal
Kruskal's Algorithm check cycle in every iteration
- Adding an edge $(v,w)$ to $T$ creates a cycle iff $T$ already contain $v-w$ path
	- $v-w$ path does not necessarily be an one edge

To identify whether $T$ contains a path between a given pair of vertices, we utilize the Union-Find Data Structure
- Maintain a partition of the static set of objects
- In the initial partition, each object is in its own set
- Once some sets are merged, they never split

$v$ and $w$ being in the same set of the partition means that $T$ contains $v-w$ path

## Use union-find data structure to keep track of the connected components of the so-far solution
1. Each vertex is in its own connected component at the beginning
	- Initialize
2. When $(v,w)$ is added to the so-far solution, components that contain $v$ and $w$ merge into one
3. Checking cycle is checking whether $v$ and $w$ are already in the same component

## Operators
**Initialize:** Given an array $X$ of objects, create a union-find structure with each object $x\in X$ in its own set
- $\mathcal{O}(n)$

**Find:** Find object $x$ in the data structure, and return the name of the set that contains $x$
- $\mathcal{O}(\log(n))$

**Union:** Merge the sets that contain $x$ and $y$ into a single set
- If two objects are already in the same set, do nothing
- $\mathcal{O}(\log(n))$

---
## Pseudocode
**//** Initialization
$T:=\emptyset$
$U:=\text{ Initialization(V)}$  
$\text{sort edges of E by cost}$ 
**//** Main loop
**for** each $(v,w)\in E$ in nondecreasing order of cost **do**
	**if** $\text{Find}(U,v)\neq \text{Find}(U,w)$ **then**
		**//** no $v-w$ path in $T$, so OK to add $(v,w)$
		$T:=T\cup \{ (v,w) \}$
		**//** update due to component fusion
		$\text{Union}(U, v,w)$
**return** $T$

---
## Total Running Time: $\mathcal{O}((m+n)\log(n))$
$\text{(Total Running Time)}=\text{(Preprocessing)}+\text{(Total Running Time for Find)}+\text{(Total Running time for Union)}$
1. $\text{(Preprocessing)}=\text{(Initialization)+(Sorting Edges)}=\mathcal{O}(n)+\mathcal{O}(m\log(n))$

2. $(\text{Total Running Time for Find})=\text{(\# Iteration)}\times \text{(\# Find per iteration)}\times \mathcal{O}(\log(n))$
	- There are 2 $\text{Find}$ operations per iteration
	- And we iterates this $m$ times
	- $=2\cdot m\cdot \log(n)\implies\mathcal{O}(m\log(n))$

3. $\text{(Total Running Time for Union)}=\text{(\# Iteration)}\times \text{(\# Union per Iteration)}\times \mathcal{O}(\log(n))$
	- There are one $\text{Union}$ operation per iteration
	- And we iterate this $n-1$ times
		- Technically, we iterate this $m$ times, but minimum required number of edges is $n-1$
	- $(n-1)\cdot\log(n)\implies \mathcal{O}(n\log(n))$

$\therefore \text{(Total Running Time)}=(m+n)\log(n)$
