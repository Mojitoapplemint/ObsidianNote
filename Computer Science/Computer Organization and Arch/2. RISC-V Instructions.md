# Arithmetic Operation
*Design Principle: Simplicity favours regularity*
- Simpler implementation
- Enables higher performance lower cost

Two sources and one destination
- $\text{add}\quad a,b,c\implies a\leftarrow b+c$

Where are variables actually stored **during** computations?
- In CPU, more specifically register

## Register
Extremely fast memory
- Located in CPU, close to Arithmetic and Logic Unit(ALU)

# Datapath
ALU+Registers+Internall busses
1. Instruction read from memory
2. Load data into registers
3. Processed by ALU
	- There are a few wire connected to ALU
		- Each wire represent 1 bit
		- $2^{n}$ number of operation can be assigned
	- Takes two input, and return one operand
4. Read or write to memory
	- Only Load/Store instruction goes to memory
5. Results written to registers
	- By repeting 1~4

# 
$$\text{(Opcode) }$$
**Note)** addi instruction add the immediate value. That immediate value is stored in the instruction itself, not in register. Since each instruction has assigned bits, the value of immediate constant is limited

# Register Operands
Arithmetic instructions use register operands
- RISC-V has $32\times 32$-bit register
- Use for requently accessed data
- $32$-bit data called a word
- Note that $x_{0}$ is hard-coded to the constant 0

*Design Prinple: Smaller is faster*

# Memory Operands
Where is memory used?
- Main memory used for composite data, such as arrays, structures, dynamic data.
- Store/Load values between memory and register

Memory is byte addressed
- Each addressed identifies 8-bit byte

RISC-V does not require words to be aligned in memory, except for instructions and the stack

Memory operations are slow
- This means instructions that require memory operations take longer than instruction that don't

