# Datapath
ALU+Registers+Internall busses
1. Instruction read from memory
2. Load data into registers
3. Processed by ALU
	- There are a few wire connected to ALU
		- Each wire represent 1 bit
		- $2^{n}$ number of operation can be assigned
	- Takes two input, and return one operand
4. Read or write to memory
	- Only Load/Store instruction goes to memory
5. Results written to registers
	- By repeting 1~4

# Design Principle
## 1. Simplicity favours regularity
Simpler implementation

Enables higher performance lower cost

## 2. Smaller is faster

## 3. Make the Common Case Faster
Small constants are common
- Like 0

Immediate operand aviods an expensive load instruction

## 4. Good Design demands good compromises
# Operands
## Register Operands
Arithmetic instructions use register operands
- RISC-V has $32\times 32$-bit register
- Use for requently accessed data
- $32$-bit(4 bytes) data called a word
- Note that $x_{0}$ is hard-coded to the constant 0

## Memory Operands
Where is memory used?
- Main memory used for composite data, such as arrays, structures, dynamic data.
- Store/Load values between memory and register

Memory is byte addressed
- Each addressed identifies an 8-bit byte

RISC-V does not require words to be aligned in memory, except for instructions and the stack

Memory operations are slow
- Because data conveyment between memory and CPU is slow
- This means instructions that require memory operations take longer than instruction that don't

### Registers vs Memory
Register is faster to accesses
- Compiler must use registers for variables as much as possible
- Only spill to memory for less frequently used variables
- Register optimization is important

## Immediate Operands
Constant data(Immediate value) is specified in an instruction
- The value is stored in the instruction itself, not in register
- Since each instruction has limited bits, the value is limited

# Representing Instruction
Instruction are encoded in binary
- Called Machine Code

RISC-V Instruction
- Encoded as 32-bit words
- Consist of opcode, register numbers, etc
- Format
	- R-Type: Opcode and 3 registers
	- I-Type: Opcode, 2 registers and 1 immediate value
	- S-Typle: Store

Each instruction consist of field, segment of an instruction, which may represent
- Register Number
- Opcode: Operation code
- Immediate Values

## R-Type Instruction
Instruction
$$\small\text{(Opcode)}\quad  \text{(Destination Register), } \text{ (Source Register 1), } \text{ (Source Register 2)}$$

Format
![[Pasted image 20250118001354.png|600]]

Instruction field
- Opcode: Operation code
- funct7: An additional opcode field
- rs2: Second register source operand
- rs1: First register source operand
- rd: Register Destination
- funct3: An additional opcode field

## I-Type Instruction
Used by Immediate instruction and load instruction
$$\small\text{(Opcode)}\quad  \text{(Destination Register), } \text{ (Source Register 1), } \text{ (Immediate Value)}$$

Format
![[Pasted image 20250120154111.png|600]]

Immediate Field is zero extended
- Immediate value can be between $-2^{11}$ ~ $2^{11}-1$
	- Or $0$~$2^{12}$


## S-Type Instruction
Store Instruction

Format
![[Pasted image 20250120160542.png|600]]

12 bit immediate is split into two field, lower 5 bits and upper 7 bits
- 

# Binary Integers
Given $n$-bit number with bits $x_{n-1}, x_{n-2}\dots x_{1}, x_{0}$
- $x=x_{n-1}2^{n-1}+x_{n-2}2^{n-2}\dots x_{1}2^{1}+x_{0}2^{0}$

## Numbering of bits in RISC-V
![[Pasted image 20250118142702.png|500]]
Right to left numbering in a doubleword
- Least significant bit: Rightmost bit (numbering 0)
- Most significant bit: Leftmost bit (numbering 31)

Thus, we can express $2^{32}$ different pattern
- $0$ ~ $2^{32}-1$ : *Unsigned numbers*
	- Overflow: When the result of operation cannot be represented by rightmost hardware bits
- $-2^{31}$ ~ $2^{31}-1$ : *two's complement* representation
	- Leading 0s mean positive, Leading 1s mean negative
	- All negatives have 1 at the most significant bit, thus computer can distinguish positive or negative by checking one bit
		- This bit is called *sign bit*

### Useful Shortcuts from Two's Complement
1. Negating two's complement binary
	- Invert every 0 to 1 and vice versa, then add 1
		- Let it $\bar{x}$
	- $x+\bar{x}=-1$
2. Sign Extension: Converting binary number represented in $n$-bits to a number represented with more than $n$-bits
	- Take the most significant bit from smaller quantity, replicate it to fill the new bits of the larger quantity


---
# Side Note: Hexadecimal
Base 16
- Compact representation of bit strings
- 4 bits per hex digit
![[Pasted image 20250120153713.png]]
