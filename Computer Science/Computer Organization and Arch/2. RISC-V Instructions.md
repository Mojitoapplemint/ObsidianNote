# Datapath
ALU+Registers+Internall busses
1. Instruction read from memory
2. Load data into registers
3. Processed by ALU
	- There are a few wire connected to ALU
		- Each wire represent 1 bit
		- $2^{n}$ number of operation can be assigned
	- Takes two input, and return one operand
4. Read or write to memory
	- Only Load/Store instruction goes to memory
5. Results written to registers
	- By repeting 1~4

# Design Principle
## 1. Simplicity favours regularity
Simpler implementation

Enables higher performance lower cost

## 2. Smaller is faster

## 3. Make the Common Case Faster
Small constants are common
- Like 0

Immediate operand aviods an expensive load instruction

# Operands
## Register Operands
Arithmetic instructions use register operands
- RISC-V has $32\times 32$-bit register
- Use for requently accessed data
- $32$-bit(4 bytes) data called a word
- Note that $x_{0}$ is hard-coded to the constant 0

## Memory Operands
Where is memory used?
- Main memory used for composite data, such as arrays, structures, dynamic data.
- Store/Load values between memory and register

Memory is byte addressed
- Each addressed identifies an 8-bit byte

RISC-V does not require words to be aligned in memory, except for instructions and the stack

Memory operations are slow
- Because data conveyment between memory and CPU is slow
- This means instructions that require memory operations take longer than instruction that don't

### Registers vs Memory
Register is faster to accesses
- Compiler must use registers for variables as much as possible
- Only spill to memory for less frequently used variables
- Register optimization is important

## Immediate Operands
Constant data(Immediate value) is specified in an instruction
- The value is stored in the instruction itself, not in register
- Since each instruction has limited bits, the value is limited

# Representing Instruction
Instruction are encoded in binary
- Called Machine Code

RISC-V Instruction
- Encoded as 32-bit words
- Consist of opcode, register numbers, etc
- Format
	- R-Type: Opcode and 3 registers
	- I-Type: Opcode, 2 registers and 1 immediate value
	- S-Typle: Store

## R-Type Instruction
Instruction
$$\small\text{(Opcode)}\quad  \text{(Destination Register), } \text{ (Source Register 1), } \text{ (Source Register 2)}$$

Memory Allocation
![[Pasted image 20250118001354.png|600]]

Instruction field
- Opcode: Operation code
- funct7: An additional opcode field
- rs2: Second register source operand
- rs1: First register source operand
- rd: Register Destination
- funct3: An additional opcode field

# Binary Integers
Given $n$-bit number with bits $x_{n-1}, x_{n-2}\dots x_{1}, x_{0}$
- $x=x_{n-1}2^{n-1}+x_{n-2}2^{n-2}\dots x_{1}2^{1}+x_{0}2^{0}$

## Numbering of bits in RISC-V
![[Pasted image 20250118142702.png|500]]
Right to left numbering in a doubleword
- Least significant bit: Rightmost bit (numbering 0)
- Most significant bit: Leftmost bit (numbering 31)

Thus, we can express $2^{32}$ different pattern
- $0$ ~ $2^{32}-1$ : Unsigned numbers
	- Overflow: When the result of operation cannot be represented by rightmost hardware bits
- $-2^{31}$ ~ $2^{31}-1$ : two's complement representation
	- Leading 0s mean positive, Leading 1s mean negative

---
# Side Note: Hexadecimal
Base 16
- Compact representation of bit strings
- 4 bits per hex digit

