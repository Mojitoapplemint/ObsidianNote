NFA with Stack
- PDA can push symbols on the stack and pop them later
- Stack can hold unlimited amount of information
	- Allows PDA to store number os unbounded size

# State Transition in PDA
PDA reads input, pop symbols from stack, and push symbol to the stack for each state transition.

![[Pasted image 20250219215916.png|250]]
- $a$ : Reading input
- $b$ : Pop and read symbol from the stack
- $c$ : Push a new symbol to the stack

Transition occurs only when PDA can read $a$ and pop $b$. Otherwise, transition will not happen
- All $a,b,c$ can be $\varepsilon$
# Formal Definition of PDA
A pushdown automaton is a 6-tuple $\left( Q,\sum,\Gamma,\delta,q_{0},F \right)$ where $Q,\sum,\Gamma,F$ are all finite set
- $Q$ is the set of states
- $\sum$ is the input alphabet
- $\Gamma$ is the stack alphabet
- $\delta:Q\times\sum_{\varepsilon}\times\Gamma_{\varepsilon}\longrightarrow \mathcal{P}(Q\times\Gamma_{\varepsilon})$
- $q_{0}\in Q$ is the start state
- $F\subseteq Q$ is the set of accept states

## Transition Function
Domain : $Q\times\sum_{\varepsilon}\times\Gamma_{\varepsilon}$
- Current state, input symbol, and top of the stack will determine the next state
- If either symbol is $\varepsilon$, it is not reading anything

Range : $\mathcal{P}(Q\times\Gamma_{\varepsilon})$
- The result of state transition may allow PDA to enter a new state and push a symbol
- Due to the nondeterminism, a situation may have several legal next moves

## Computation of PDA
PDA $M$ accepts input $w$ if $w$ can be written as $w=w_{1}w_{2}\dots w_{m}$ where each $w_{i}\in \sum_{\varepsilon}$ and sequences of states $r_{0}, r_{1}\dots r_{m}\in Q$ and strings $s_{0},s_{1}\dots s_{m}\in\Gamma^{*}$ exist that satisfy the following three conditions
1. $r_{0}=q_{0}$ and $s_{0}=\varepsilon$
	- Signifies that $M$ starts out properly in the start state and with an empty sta
2. For $i=0\dots m-1$, we have $(r_{i+1}, b)\in\delta(r_{i}, w_{i+1}, a)$ where $s_{i}=at$ and $s_{i+1}=bt$ for some $a,b\in\Gamma_{\varepsilon}$ and $t\in\Gamma^{*}$
	- States that $M$ moves properly according to the state, stack and next input symbol
3. $r_{m}\in F$
	- Accepts state occurs at the input end
# Using $
Using $, we can test empty stack
- Push $ to the stack at first
- If PDA sees $ ever again, it knows that the stack is empty

This also allows PDA to test whether it reached the end of the input string

# Example
## $L=\{ 0^{n}1^{n}\text{ | }n\geq 0 \}$
![[Pasted image 20250219225648.png|300]]

## $L = \{ a^{i}, b^{j}, c^{k}\text{ | }i,j,k\geq0 \text{ and }i=j \text{ or }i=k\}$
![[Pasted image 20250219225529.png|400]]

## $L=\{ ww^{\mathcal{R}}\text{ | }w\in \{ 0,1 \}^{*} \}$
![[Pasted image 20250219225624.png|300]]

# Equivalence with CFG
Both CFG and PDA are caple of describing the class of CFL
- CFG can generate CFL
- PDA can recognizes CFL

This means that we can use both to prove that certain language is context free
- Note that certain language is more easily described in terms of generators, whereas others are more easily described by recognizers

**Theorem : A language is context free iff some PDA recognizes it**

## Lemma 2.21 : If a language is context free, then some PDA recognizes it
Let $A$ be CFL, then by definition, there is some CFG $G$ that generates $A$
- Let's convert $G$ into an equivalent PDA, $P$

Informal description of $P$
1. Place the marker symbol $ and the start variable on the stack. 
2. Repeat the following steps forever.
	1. If the top of stack is a variable symbol $A$, nondeterministically select one of the rules for $A$ and substitute $A$ by the string on the right-hand side of the rule. 
	2. If the top of stack is a terminal symbol $a$, read the next symbol from the input and compare it to $a$. If they match, repeat. If they do not match, reject on this branch of the nondeterminism.
	3. If the top of stack is the symbol $, enter the accept state. Doing so accepts the input if it has all been read.

Let $P=\left( Q,\sum,\Gamma,\delta,q_{\text{start}}, F \right)$

Suppose we want the PDA go from state $q$ to $r$ when it reads $a\in\sum$, pops $s\in\Gamma$, and push the entire string $u=u_{1}u_{2}\dots u_{l}$
- We can do this by introducing new states $q_{1},q_{2}\dots q_{l-1}$ and transition function
$$$$
