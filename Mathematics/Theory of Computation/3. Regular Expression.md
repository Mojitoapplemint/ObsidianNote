Series of languages combined with regular operations

e.g. $(0\cup1)0^{*}$
- $0$ and $1$ refers to $\{ 0 \}$, $\{ 1 \}$
	- $(0\cup 1)\implies \{ 0 \}\cup\{ 1 \}=\{ 0,1 \}$
	- $0^{*}=\{ 0 \}^{*}$
- Concatenation ( . ) if often implies
	- $(0\cup1)\text{ . }0^{*}$

# Definition
$R$ is regular expression if $R$ :
- $a$ for some $a\in \sum$
- $\varepsilon$ 
- $\emptyset$ 
- Union of two regular expressions
	- $R_{1}\cup R_{1} =R_{1}|R_{2}$
- Concatenation of regular expressions
- Star operation of regular expression

## Anchors
- `^`: The beginning of the line
- `$`: End of the line

## Matching Operators
- `.`: Any single character, except line break
- `[...]`: Any character in this set
	- Ranges are allow by using `-` and ASCII code
	- `^` for "Not in this set" at the beginning 
- `{...}`: Any String in this set

## Iterations
 Apply to the immediately preceding item(letter or set)
- `*`: Zero or more times
- `+`: One or more times
- `?`: Zero or one time
	- $a? = \{ a \}\cup \{ \varepsilon \}$
- $R^{k}$ : Concatenation of $k$ $R's$ with each other

## Prededence rules
1. $^{*},+,?$ before .
2. "." before $\cup$
3. Parenthesis when needed

$\implies$ Iteration $\to$ Concatenation $\to$ Union

## $\emptyset$ vs $\varepsilon$
$\varepsilon$ is a language containing a single string that is empty string.
$\emptyset$ represents the language that doesn't contain any string


If $R$ is regular expressions, then
1. $R\cup \emptyset =R$
2. $R.\emptyset=\emptyset$
	- $\text{abc}\emptyset=\emptyset$
3. $R.\varepsilon=R$
4. $R\cup\varepsilon=R\cup \{ \varepsilon \}$
	- Just regular expression with empty string added
5. $\emptyset^{*}=\varepsilon$

# Theorem: Regular language and Regular Expression
A language is regular iff some regular expression describes it

## Lemma 1
For every simple language $S$, there is a finite automata $M$ such that $L(M)=S$

**Proof)**
Language $\emptyset$
![[Pasted image 20250128120146.png]]

Language $\{ a \}$
![[Pasted image 20250128120424.png|250]]

Language $\varepsilon$
![[Pasted image 20250204004007.png]]

## Prove
$(\to)$
If Language is regular, then there is some DFA(NFA) that accepts it
- We can convert NFA to regular expression, describe below

Therefore, if a language is regular, then there is regular expression that describe it

$(\leftarrow)$
Suppose regular expression $R$ describes some language $A$
- We are going to build NFA that accepts $A$
- By Corolarry 1.40, $A$ must be regular

By Lemma 1, we know that there is NFA for $\emptyset, \varepsilon$ and $\forall \text{ } a\in \sum$

For concatenation, union, star, we can construct NFA from previous chapter

# Finite Automata to Regular Expression
## Generalized Nondeterministic Finite Automata (GNFA)
NFA wherein the transition arrows may have any regular expressions as labels
- Transition by reading a substring described by regex
- Accepts input if its processing can cause GNFA to be in an accept state at the end of the 

## Steps
1. Create a unique initial state and final state by $\varepsilon$ transition
2. Choose one state rip it
	- Consider the paths 
		- Input state $\xrightarrow{\text{Incoming}}$ chosen state $\xrightarrow{\text{Outgoing}}$ output state
	- Find incoming transition, self loop and outgoing transition of the path
		- If there is no self loop, we consider self loop of $\emptyset$, since $\emptyset^{*}=\varepsilon$
	- Write regular language that represents each path
		- $\text{(Incoming)(Loop)}^{*}\text{(Outgoing)}$
	- This means that each language would represent the transition between input and output state
3. Remove the chosen state from state transition diagram and add the new transition created from 2
	- If the transition from input state to output state already exists, union them

