Automata Theory deals with the definitions and properties of mathematical models of computation

# Vocabularies
Alphabet ($\sum$)
- Any nonempty finite set

Symbols
- Elements of the alphabet

String over an alphabet
- Finite sequence of symbols from that alphabet
	- $\sum^{k}$ ($k\geq\mathbb{Z}^{+}$) : Set of all strings with length $k$
	- $\sum^{*}$ : Set of all strings over alphabet
	- $\sum^{+}$ : Set of all strings with length at least 1
		- $\sum-\{ \varepsilon \}$
- Length of the string refers to number of symbols in it

Empty String ($\varepsilon$)
- String with length 0

Reverse of $w$ ($w^{\mathcal{R}}$)
- Obtained by writing $w$ in reverse order

Concatenation
- Concatenation of $x$ and $y$, denoted as $xy$, is appending $y$ after $x$

Lexicographic
- i.e. Dictionary Order
- Shortlex Order(String order) : lexicographic order + shorter string firsts

Language
- Set of strings chosen from $\sum^{*}$
- If $\sum$ is an alphabet and $L\subseteq \sum^{*}$, then we say $L$ is a language over $\sum$

# Formal Definition of Finite Automata
A finite automaton $M$ is 5-tuple$\left( Q,\sum, \delta, q_{0}, F \right)$
- $Q$ : Finite set of states
- $\sum$ : Finite set of alphabet symbols
- $\delta$ : Transition function $\delta: Q\times \sum\to Q$
- $q_{0}$ : Start state
- $F$ : Set of accept states

**Ex above)**
$M_{1}:\left( Q,\sum,\delta,q_{0},F \right)$
$Q:\{ q_{0},q_{1},q_{2} \}$
$\sum:\{ 0,1 \}$
$F:\{ q_{2} \}$

| $\delta=$ | 0       | 1       |
| --------- | ------- | ------- |
| $q_{0}$   | $q_{0}$ | $q_{1}$ |
| $q_{1}$   | $q_{0}$ | $q_{2}$ |
| $q_{2}$   | $q_{2}$ | $q_{2}$ |

# Computation of DFA
## Deterministic Finite Automata(DFA)
Finite Automaton that for every symbol of an input string read, we will always *know what the next state* will be
- The next state is determined
- Nondeterministic machine, several choices may exist for the next state at any point

## Computation Process
1. Begin at start state
2. Read Input symbols
3. Follow Corresponding transitions
4. Accept if ends in accepet state
	- Reject if not

## I/O
Input: Finite String
- But automata will process each alphabet at a time
Output
- Accept or Reject

## Formal Definition of Computation
Let $M=\left( Q, \sum, \delta, q_{0}, F \right)$ be a Finite Automaton and let $w=w_{1}w_{2}\dots{w}_{n}$ be a string where each $w_{i}\in \sum$. Then $M$ accepts $w$ if a sequence of states $r_{0},r_{1}\dots r_{n}$ exists with three conditions
1. $r_{0}=q_{0}$
2. $\delta(r_{i}, w_{i+1})=r_{i+1}$, for $i=0,1,2,\dots n-1$
3. $r_{n}\in F$

Condition 1 forces the machine starts in the start state
Condition 2 says that all state transition that machine made is according to the transition funciton
Condition 3 says that machine accepts its input iff it ends up in an accept state

## Language
If $A=\{ w\text{ | } M \text{ accepts } w\}$, then we say that
- $M$ recognizes $A$
- $A$ is language of $M$
	- Denoted as $A=L(M)$

### Regular Language
- A language recognized by some finite automata

**Ex)**
![[Pasted image 20250107230029.png|400]]
$A=\{ w:w\text{ contains substring 11} \}$

**Ex)** Is $\sum^{*}$ regular?
- Yes, is there is single state with self loop for $\sum$

## How to Construct Finite Automaton from its Language
1. Determine what I need to remember about the strings
2. Represents this information as a finite list of possibilities
	- Assign a state to each of the possibilities
3. Assign the transitions by seeing how to go from one possibility to another upon reading a symbol
4. Set start state and accept state

# Regular Operation
Operations on languages
- Union: $A\cup B=\{ x|x\in A\text{ or }x\in B \}$
- Concatenation: $A\circ B=\{ xy\text{ | }x\in A\text{ or }y\in B \}$
- Star: $A^{*}=\{ x_{1}x_{2}\dots x_{k}\text{ | }k\geq 0\text{ and each }x_{i}\in A \}$

## Theorem 1.25
The class of regular languages is closed under the union operation
- i.e. If $A_{1}$ and $A_{2}$ are regular languages, so is $A_{1}\cup A_{2}$

**Proof)**
Let
- $M_{1}$ recognize $A_{1}$, where $M_{1}=\left( Q_{1}, \sum_{1}, \delta_{1}, q_{1}, F_{1} \right)$
- $M_{2}$ recognize $A_{2}$, where $M_{2}=\left( Q_{2}, \sum_{2}, \delta_{2}, q_{2}, F_{2} \right)$

Construct $M$ to recognize $A_{1}\cup A_{2}$, where $M=\left( Q, \sum, \delta, q_{0}, F \right)$
1. $Q=\{ (r_{1},r_{2})\text{ | }r_{1}\in Q_{1} \text{ and }r_{2}\in Q_{2}\}$
	- This set is the cartesian product of sets $Q_{1}$ and $Q_{2}$
2. $\sum=\sum_{1}\cup \sum_{2}$
3. $\delta((r_{1},r_{2}), a)=(\delta_{1}(r_{1},a), \delta_{2}(r_{2},a))$
4. $q_{0}=(q_{1},q_{2})$
5. $F$ is the set of pairs in which either member is an accept state of $M_{1}$ or $M_{2}$
$$F=\{ (r_{1},r_{2})\text{ | }r_{1}\in F_{1}\text{ or }r_{2}\in F_{2}\}$$
$$=(F_{1}\times Q_{2})\cup (Q_{1}\times F_{2})$$

## Theorem 1.26
The class of regular languages is closed under the concatenation operation
- i.e. If $A_{1}$ and $A_{2}$ are regular languages, so is $A_{1}\circ A_{2}$

Similar proof with above. Instead of constructing automaton $M$ to accept its input if either $M_{1}$ or $M_{2}$ accept, it must accept if its input can be broken into two pieces, where $M_{1}$ accepts the first piece and $M_{2}$ accepts the second piece

# Intersection and Union of Finite Automata
A language is just a set of words, so we can take intresection or union
- We need a systematic way of constructing the automata for $L_{1}\cup L_{2}$ and $L_{1}\cap L_{2}$, using the automata for $L_{1}$ and $L_{2}$

## Product Construction
Let $M_{1}=\left( Q_{1}, \sum, \delta_{1}, q_{0,1}, F_{1} \right)$ and $M_{2}=\left( Q_{2}, \sum, \delta_{2}, q_{0,2}, F_{2} \right)$

Then, $M_{\cap}=\left( Q,\sum, \delta, q_{0}, F_{\cap} \right)$
- $Q=Q_{1}\times Q_{2}$
- $\delta((q_{1},q_{2}), e)=(\delta_{1}(q_{1}, e), \delta_{2}(q_{2},e))$
- $q_{0}=(q_{0,1}, q_{0,2})$
- $(q_{1},q_{2})\in F_{\cap}$ iff $q_{1}\in F_{1}$ and $q_{2}\in F_{2}$

Then, $M_{\cup}=\left( Q,\sum, \delta, q_{0}, F_{\cup} \right)$
- $Q=Q_{1}\times Q_{2}$
- $\delta((q_{1},q_{2}), e)=(\delta_{1}(q_{1}, e), \delta_{2}(q_{2},e))$
- $q_{0}=(q_{0,1}, q_{0,2})$
- $(q_{1},q_{2})\in F_{\cup}$ iff $q_{1}\in F_{1}$ or $q_{2}\in F_{2}$

### Example)
Let Languages $A,B$ are following
- $A=\{ w\text{ | } w\text{ has an odd number occurence of }1\}$
- $B=\{ w\text{ | } w\text{ contains substring 000}\}$

Draw state transition diagram for DFA that accepts $A\cup B$ and $A\cap B$

First, draw state transition diagram for automaton that accepts $A$ and $B$
- $A$
![[Pasted image 20250117120258.png|250]]

- $B$
![[Pasted image 20250117120321.png|300]]

Then,
- DFA for $A\cap B$
![[Pasted image 20250117120419.png|350]]

- DFA for $A\cup B$
![[Pasted image 20250117120442.png|350]]

## What if the alphabet of two automatons are different
Union
- Take $\sum=\sum_{1}\cup \sum_{2}$, and redefine each automaton with the updated alphabet. Then, do the same thing

Intersection
- Need to be extra cautious about whether intersection of both language exists

### Example)
Let Languages $A,B$ are following
- $A=\{ w\in \{ 0,1 \}^{*}\text{ | } w\text{ has an odd number occurence of }0\}$
- $B=\{ w\in \{ 1,2 \}^{*}\text{ | } w\text{ begins and ends with the same alphabet}\}$

Draw a state transition diagram of DFA that accepts $A\cup B$ and $A\cap B$

Let
- $\hat{A}=\{ w\in \{ 0,1,2 \}^{*}\text{ | } w\text{ has an odd number occurence of }0\}$
- $\hat{B}=\{ w\in \{ 0,1,2 \}^{*}\text{ | } w\text{ begins and ends with the same alphabet}\}$

Then, state transition diagram for 
- $\hat{A}$
![[Pasted image 20250117121832.png|250]]

- $\hat{B}$
![[Pasted image 20250117121911.png|350]]

Then, state transition diagram for 
- $A\cup B$
![[Pasted image 20250117220658.png|450]]

- $A\cap B$
	- Observe that there is no such $w$ that satisfy both $A$ and $B$
	- Empty Language

![[Pasted image 20250121185841.png|100]]

# Merge Language
For two languages $L_{1}$ and $L_{2}$, we write $L_{1}||L_{2}$ foe the set of words that result from merging a word in $L_{1}$ and a word in $L_{2}$
$\{ a,ab \}||\{ 01 \}=\{ a01, 0a 1, 01a, ab 01, a 0 b 1, 0ab 1,  \}$

## Building $M_{||}$
Let $M_{1}=\left( Q_{1}, \sum, \delta_{1}, q_{0,1}, F_{1} \right)$ and $M_{2}=\left( Q_{2}, \sum, \delta_{2}, q_{0,2}, F_{2} \right)$

Then, $M_{||}=\left( Q,\sum, \delta, q_{0}, F_{||} \right)$
- $Q=Q_{1}\times Q_{2}$
- $\delta((q_{1},q_{2}), e)=\{ (\delta_{1}(q_{1}, e), q_{2}), (q_{1},\delta(q_{2},e)) \}$
- $q_{0}=(q_{0,1}, q_{0,2})$
- $(q_{1},q_{2})\in F_{||}$ iff $q_{1}\in F_{1}$ and $q_{2}\in F_{2}$

Transition function now returns set of multiple path
- No longer deterministic

# Nondeterministic Finite Automata (NFA)
Each state has stochastic transition for each symbol in the slphabet

A nondeterministic finite automaton $M$ is 5-tuple$\left( Q,\sum, \delta, q_{0}, F \right)$
- $Q$ : Finite set of states
- $\sum$ : Finite set of alphabet symbols
- $\delta$ : Transition function $\delta: Q\times \sum_{\varepsilon}\to \mathcal{P}(Q)$
	- Where $\mathcal{P}(Q)$ is power set
	- $\sum_{\varepsilon}=\sum\cup \{ \varepsilon \}$
- $q_{0}$ : Start state
- $F$ : Set of accept states

## Computation of NFA
After processing all symbols, at least one possibility shuold be in the accepting state.
- Even though we reached accepting state, if we still have unprocessed input and there is no way to process, it's dead end (wrong)

### Formal Definition of Computation
Let $N$ be an NFA and $w=y_{1}\dots y_{m}$ a string over the alphabet $\sum$. Then we say $N$ accepts $w$ if $y_{i}\in \sum_{\varepsilon}$ and a sequence of states $r_{0}, r_{1}\dots r_{m}$ exists in $Q$ with three condition
1. $r_{0}=q_{0}$
2. $r_{i+1}\in\delta(r_{i}, y_{i+1})$ for $i=0,\dots m-1$
3. $r_{m}\in F$

## $\varepsilon$-Transition
Multiple explicit paths from one state to others with the same transition label
- Sometimes it is convenient to permit that an automation transitions without reading an input symbol
- Such tansitions are called $\varepsilon$-transitions, where $\varepsilon$ is the empty word

$M^{\varepsilon}=\left( Q,\sum^{\varepsilon}, \delta^{\varepsilon}, q_{0}, F^{\varepsilon} \right)$
- $\sum^{\varepsilon}=\sum\cup \{ \varepsilon \}$
- $\delta^{\varepsilon}:Q\times \sum^{\varepsilon}\to \mathcal{P}(Q)$

### Computation
Without reading any input, the machine splits into multiple copies, one following each of the existing $\varepsilon$-labeled arrows and one staying at the current state. Then the machine proceeds nondeterministically as before.

## Nondeterminism vs Determinism
Nondeterminism is exponentially more simple than determinism
- Suppose we want to check if the $k^{th}$ leter from the end of the input is 1
	- An NFA can check this with $k+1$ states
	- DFA must remember the $k$most recent input symbols, which means $2^{k}$ states

## NFA to DFA
For every NFA $N$, there is a DFA $D$ such that $L(N)=L(D)$
- We say that two machines are equivalent if they recognize the same language

### Subset Construction Algorithm
1. Starts with the same initial state
2. Each state is going to be a set of possible transition state from initial state with certain alphabet input
	- Each different set is going to be a new state
3. Repeat the same process for all set
	- If transition leads to set already exist, connect them
	- Otherwise, create a new set 
4. The set that contains accepting state is going to be accepting states for DFA

**Ex)**
Following NFA
![[Pasted image 20250121191923.png|400]]

is correspondent to following DFA

![[Pasted image 20250121192503.png|200]]

### Corollary Theorem
A language is regular iff some NFA recognizes it

## Intersection and Union of NFA
Can compute union and intersection of NFAs using the product construction
- But there is simpler way for union

1. Create a new starting state
2. Create paths from new starting state to starting state to each NFAs with $\varepsilon$ transition

# Complementation
$L^{c}=\sum^{*}/L$

## Drawing DFA for Complementation of $L$
Suppose DFA $M$ accepts language $L$
DFA that accepts the complement of $L$, called $M^{c}$, looks the same to $M$, except switching accepting state to nonaccepting state and vice versa

**Note)** This does not work for NFA

