# Grammar
Describe certain features that have a recursive structure, which makes them useful in a variety of application

A grammar consists of a collection of **subsitution rules** (a.k.a production)
- Format: $\text{(variable)}\to\text{(terminals)}$
	- Variable : Capitalized
	- Terminals : Lower case, numbers, special symbols
- One variable is designated as a *start variable*
	- Typically topmost
- A sequence of substitutions to obtain a string is called a derivation
## Generate String
1. Write down the start variable. It is the variable on the left-hand side of the top rule, unless specified otherwise. 
2. Find a variable that is written down and a rule that starts with that variable. Replace the written down variable with the right-hand side of that rule. 
3. Repeat step 2 until no variables remain.

**Ex)**
Let $G$
- $A\to 0A 1\text{ | }B$
	- $A\to0A1$ or $A\to B$
- $B\to\#$

$A\implies 0A 1\implies 00A 11\implies 000A 111\implies 000B 111 \implies 000\# 111$
$\therefore L(G)=\{ 0^{n}\# 1^{n}\text{ | }n\geq 0\}$

# Context-free Grammar (CFG)
A context-free grammar is a 4-tuple $\left( V,\sum,R,S \right)$ where
1. $V$ : Variables (finite)
2. $\sum$ : Terminals; finite, disjoint from $V$
3. $R$ : Finite set of rules
4. $S\in V$ : Start variable

If $u, v$, and $w$ are strings of variables and terminals, and $A â†’ w$ is a rule of the grammar, we say that $uAv$ *yields* $uwv$, written $uAv \Rightarrow uwv$. 

$u$ derives $v$
- $u\xRightarrow{*}v$
- If $u=v$ or $u_{1},u_{2}\dots u_{k}$ exists for $k\geq 0$ such that $$u\Rightarrow u_{1}\Rightarrow\dots u_{k}\Rightarrow v$$
## Language
All strings generated by grammar is called *language of the grammar*
- Denoted as $L(G)$ where $G$ is grammar

Any language that can be generated by some context-free grammar is called context-free language(CFL)
- $\left\{  w\in \sum^{*} \text{ | } S\xRightarrow{*}w  \right\}$

# Designing CFG
CFLs are the union of simpler CFLs, thus construct smaller CFGs and merge them
- Combining all rules and then adding a new rule $S\to S_{1}\text{ | }S_{2} \dots | S_{k}$ , where $S_{i}$'s are start variables of smaller CFGs

Constructing CFG for regular language is easy if we can construct DFA by converting it into CFG
- Make variable $R_{i}$ for each state $q_{i}$
- Add rule $R_{i}\to aR_{j}$ if $\delta(q_{i}, a)=q_{j}$
- Add $R_{i}\to\varepsilon$ if $q_{i}$ is accept state
- Let $R_{0}$ be start variable

Certain language is required to remember an unbounded amount of information about one substring for another
- E.g. $\{ 0^{n}1^{n}\text{ | }n\geq 0 \}$
- Handle this by rule of form $R\to uRv$
	- Amount of $u$'s and $v$'s are matching

In more complex languages, the strings may contain certain structures that appear recursively as part of other structure
- Place the variable symbol generating the structure in the location of the rules corresponding to where that structure may recursively appear

# Parse Tree
