# Grammar
Describe certain features that have a recursive structure, which makes them useful in a variety of application

A grammar consists of a collection of **subsitution rules** (a.k.a production)
- Format: $\text{(variable)}\to\text{(terminals)}$
	- Variable : Capitalized
	- Terminals : Lower case, numbers, special symbols
- One variable is designated as a *start variable*
	- Typically topmost
- A sequence of substitutions to obtain a string is called a derivation

## Regular Grammer
1. $A\to \varepsilon$
2. $A\to a$
3. $A\to B$
4. $A\to aB$ or $A\to Ba$

## Generate String
1. Write down the start variable. It is the variable on the left-hand side of the top rule, unless specified otherwise. 
2. Find a variable that is written down and a rule that starts with that variable. Replace the written down variable with the right-hand side of that rule. 
3. Repeat step 2 until no variables remain.

**Ex)**
Let $G$
- $A\to 0A 1\text{ | }B$
	- $A\to0A1$ or $A\to B$
- $B\to\#$

$A\implies 0A 1\implies 00A 11\implies 000A 111\implies 000B 111 \implies 000\# 111$
$\therefore L(G)=\{ 0^{n}\# 1^{n}\text{ | }n\geq 0\}$

# Context-free Grammar (CFG)
A grammer where all rules are of the form
$$\text{(Single Variable)}\to\text{(Any combination of Variable and Terminals)}$$

A context-free grammar is a 4-tuple $\left( V,\sum,R,S \right)$ where
4. $V$ : Variables (finite)
5. $\sum$ : Terminals; finite, disjoint from $V$
6. $R$ : Finite set of rules
7. $S\in V$ : Start variable

If $u, v$, and $w$ are strings of variables and terminals, and $A â†’ w$ is a rule of the grammar, we say that $uAv$ *yields* $uwv$, written $uAv \Rightarrow uwv$. 

$u$ *derives* $v$
- $u\xRightarrow{*}v$
- If $u=v$ or $u_{1},u_{2}\dots u_{k}$ exists for $k\geq 0$ such that $$u\Rightarrow u_{1}\Rightarrow\dots u_{k}\Rightarrow v$$
## Language
All strings generated by grammar is called *language of the grammar*
- Denoted as $L(G)$ where $G$ is grammar

Any language that can be generated by some context-free grammar is called context-free language(CFL)
- $\left\{  w\in \sum^{*} \text{ | } S\xRightarrow{*}w  \right\}$

# Designing CFG
CFLs are the union of simpler CFLs, thus construct smaller CFGs and merge them
- Combining all rules and then adding a new rule $S\to S_{1}\text{ | }S_{2} \dots | S_{k}$ , where $S_{i}$'s are start variables of smaller CFGs

Constructing CFG for regular language is easy if we can construct DFA by converting it into CFG
- Make variable $R_{i}$ for each state $q_{i}$
- Add rule $R_{i}\to aR_{j}$ if $\delta(q_{i}, a)=q_{j}$
- Add $R_{i}\to\varepsilon$ if $q_{i}$ is accept state
- Let $R_{0}$ be start variable

Certain language is required to remember an unbounded amount of information about one substring for another
- E.g. $\{ 0^{n}1^{n}\text{ | }n\geq 0 \}$
- Handle this by rule of form $R\to uRv$
	- Amount of $u$'s and $v$'s are matching

In more complex languages, the strings may contain certain structures that appear recursively as part of other structure
- Place the variable symbol generating the structure in the location of the rules corresponding to where that structure may recursively appear

# Ambiguity
Sometimes a grammar can generate the same string in several different ways
- If so, then the string is called to be derived ambiguously in that grammar
	- The string has two different parse trees, not two different derivation
- We say that the grammar is ambiguous

A derivation of a string $w$ in a grammar $G$ is a *leftmost derivation* if at every step the leftmost remaining variable is the one replaced

## Formal Definition
A string $w$ is derived ambiguously in context-free grammar $G$ if it has *two or more different leftmost derivations*. 
- Grammar $G$ is ambiguous if it generates some string ambiguously

## Inherently Ambiguous
For some ambiguous grammer $G_{1}$, we can find an unambiguous grammer $G_{2}$ such that $L(G_{1})=L(G_{2})$

Inherently Ambiguous
- CFLs can be generated only by ambiguous grammer

# Chomsky Normal Form
A CFG is in Chomsky Normal Form if every rule is 
- $A\to BC$
- $A\to a$

where $a$ is any terminal and $A,B$ and $C$ are any variables
- $B,C$ may not be start variable
- $S\to\varepsilon$ where $S$ is start state is permitted

## Theorem 2.9
Any CFL is generated by CFG in Chomsky normal form

**Proof)**
Idea: Any grammer can be converted into Chomsky Normal Form

8. Add new start variable $S_{0}$ and rule $S_{0}\to S$, where $S$ is original start variable
	- Guarantee that start variable doesn't occur on the right-hand side of a rule
9. Remove all $\varepsilon$-rule : $A\to\varepsilon$ where $A$ is not starting variable
	- For all rules that contain $A$ in the right hand side,  add new rules without each occurence
	- If we have $R\to A$, we add $R\to\varepsilon$ unless we already removed $R\to \varepsilon$
	- Repeat this until we eliminate all $\varepsilon$-rules not involving the start variable
10. Remove all unit rules : $A\to B$
	- For every rules $B\to u$, add $A\to u$ unless this was a unit rule previously removed
	- Repeat until all unit rules are removed
11. Convert all remaining rules into proper form
	- $A\to u_{1}u_{2}\dots u_{k}\text{ } (k\geq3)$ into $A\to u_{1}A_{1}$, $A_{1}\to u_{2}A_{2}\dots A_{k-2}\to u_{k-1}u_{k}$
	- Replace any terminal $u_{i}$ in the preceding rules with the new variable $U_{i}$ and add the rule $U_{i}\to u_{i}$


# Parse Tree
